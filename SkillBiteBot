from telegram import Update
from telegram.ext import Application, CommandHandler, MessageHandler, Filters, ContextTypes
import json
import os
from datetime import datetime, timedelta
import random

# Token de BotFather (reemplazÃ¡ con el tuyo)
TOKEN = "123456:ABC-DEF1234ghIjkLoM"  # Â¡ObtenÃ© tu token de @BotFather!

# Archivo para guardar datos
DATA_FILE = "skill_bite.json"

# Banco de preguntas (idioma: inglÃ©s para empezar)
QUESTIONS = [
    {
        "question": "Â¿CÃ³mo se dice 'hola' en inglÃ©s?",
        "options": ["1. Hello", "2. Goodbye", "3. Please", "4. Thank you"],
        "correct": 1
    },
    {
        "question": "Â¿CuÃ¡l es el pasado de 'go'?",
        "options": ["1. Goes", "2. Went", "3. Going", "4. Gone"],
        "correct": 2
    },
    {
        "question": "Â¿CÃ³mo se dice 'gracias' en inglÃ©s?",
        "options": ["1. Sorry", "2. Please", "3. Thank you", "4. Hello"],
        "correct": 3
    }
]

# Respuestas motivacionales
RESPONSES = [
    "Â¡Sos una mÃ¡quina del conocimiento! ğŸ§  +5 puntos.",
    "Â¡Crack, seguÃ­ asÃ­! ğŸ”¥ +5 puntos por aprender.",
    "Â¡Pura Ã©pica mental! ğŸ˜ +5 puntos.",
    "Â¡Leyenda del saber! ğŸ“š +5 puntos, Â¿listo para mÃ¡s?"
]

# Medallas
MEDALS = [
    "ğŸ¥‰ Aprendiz de InglÃ©s: 10 puntos",
    "ğŸ¥ˆ Maestro de Vocabulario: 30 puntos",
    "ğŸ¥‡ GurÃº del Conocimiento: 50 puntos"
]

# Cargar/guardar datos
def load_data():
    if os.path.exists(DATA_FILE):
        with open(DATA_FILE, "r") as f:
            return json.load(f)
    return {"users": {}}

def save_data(data):
    with open(DATA_FILE, "w") as f:
        json.dump(data, f)

# Comando /start
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = str(update.message.from_user.id)
    data = load_data()
    if user_id not in data["users"]:
        data["users"][user_id] = {"points": 0, "premium": False, "medals": [], "last_question": None}
        save_data(data)
    question = random.choice(QUESTIONS)
    data["users"][user_id]["last_question"] = question
    save_data(data)
    options_text = "\n".join(question["options"])
    await update.message.reply_text(
        "Â¡Bienvenido a @SkillBiteBot! ğŸ§  AprendÃ© en bocados y ganÃ¡ puntos.\n"
        f"Pregunta: {question['question']}\n{options_text}\n"
        "RespondÃ© con /answer 1, /answer 2, etc.\n"
        "Comandos:\n/points - Ver tus puntos\n/premium - DesbloqueÃ¡ mÃ¡s\n/daily - Nueva pregunta"
    )

# Comando /daily (nueva pregunta)
async def daily(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = str(update.message.from_user.id)
    data = load_data()
    question = random.choice(QUESTIONS)
    data["users"][user_id]["last_question"] = question
    save_data(data)
    options_text = "\n".join(question["options"])
    await update.message.reply_text(
        f"Â¡Pregunta del dÃ­a! ğŸ“š\n{question['question']}\n{options_text}\n"
        "RespondÃ© con /answer 1, /answer 2, etc."
    )
    # Programar recordatorio (simulado, 10 segundos despuÃ©s)
    context.job_queue.run_once(
        send_reminder,
        when=10,
        data={"chat_id": update.message.chat_id}
    )

# Comando /answer
async def answer(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = str(update.message.from_user.id)
    data = load_data()
    if user_id not in data["users"] or not data["users"][user_id]["last_question"]:
        await update.message.reply_text("Â¡Primero pedÃ­ una pregunta con /daily! ğŸ“š")
        return
    try:
        user_answer = int(context.args[0])
        question = data["users"][user_id]["last_question"]
        if user_answer == question["correct"]:
            data["users"][user_id]["points"] += 5
            # Dar medallas segÃºn puntos
            if data["users"][user_id]["points"] >= 50 and "GurÃº del Conocimiento" not in data["users"][user_id]["medals"]:
                data["users"][user_id]["medals"].append("ğŸ¥‡ GurÃº del Conocimiento")
            elif data["users"][user_id]["points"] >= 30 and "Maestro de Vocabulario" not in data["users"][user_id]["medals"]:
                data["users"][user_id]["medals"].append("ğŸ¥ˆ Maestro de Vocabulario")
            elif data["users"][user_id]["points"] >= 10 and "Aprendiz de InglÃ©s" not in data["users"][user_id]["medals"]:
                data["users"][user_id]["medals"].append("ğŸ¥‰ Aprendiz de InglÃ©s")
            save_data(data)
            affiliate_link = "https://amazon.com/language-books?tag=tuafiliado123"  # ReemplazÃ¡ con tu enlace real
            await update.message.reply_text(
                f"Â¡Correcto! ğŸ‰ {random.choice(RESPONSES)}\n"
                f"QuerÃ©s aprender mÃ¡s? MirÃ¡ estos libros: {affiliate_link}\n"
                "PedÃ­ otra pregunta con /daily."
            )
        else:
            await update.message.reply_text("Â¡Uy, no! ğŸ˜… IntentÃ¡ otra con /daily.")
    except (IndexError, ValueError):
        await update.message.reply_text("UsÃ¡ /answer 1, /answer 2, etc. Ejemplo: /answer 1")

# Comando /points
async def points(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = str(update.message.from_user.id)
    data = load_data()
    user_points = data["users"][user_id]["points"]
    medals = "\n".join(data["users"][user_id]["medals"]) or "Â¡Sin medallas aÃºn, a ganarlas!"
    await update.message.reply_text(f"ğŸ§  Puntos de conocimiento: {user_points}\nMedallas:\n{medals}")

# Comando /premium
async def premium(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = str(update.message.from_user.id)
    data = load_data()
    if data["users"][user_id]["premium"]:
        await update.message.reply_text("Â¡Ya sos premium, genio! ğŸš€ UsÃ¡ /daily o /leaderboard para mÃ¡s.")
    else:
        affiliate_link = "https://amazon.com/language-books?tag=tuafiliado123"  # ReemplazÃ¡ con tu enlace real
        await update.message.reply_text(
            "Â¡Volvete premium por $2/mes! ğŸš€ Con premium tenÃ©s:\n"
            "- Preguntas personalizadas\n"
            "- Tabla de clasificaciÃ³n\n"
            "- Canal exclusivo con mini-cursos\n"
            f"PagÃ¡ en: t.me/InviteMember (simulado) o mirÃ¡ estos libros: {affiliate_link}"
        )

# Programar recordatorio
async def send_reminder(context: ContextTypes.DEFAULT_TYPE):
    await context.bot.send_message(
        context.job.context["chat_id"],
        "Â¡No te pierdas la pregunta de hoy! ğŸ“š UsÃ¡ /daily para aprender y ganar puntos. @SkillBiteBot"
    )

# Manejar mensajes
async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = str(update.message.from_user.id)
    data = load_data()
    if user_id not in data["users"]:
        data["users"][user_id] = {"points": 0, "premium": False, "medals": [], "last_question": None}
        save_data(data)
    await update.message.reply_text(
        f"Â¡Vamos, genio! ğŸ§  PedÃ­ una pregunta con /daily o chequeÃ¡ tus puntos con /points."
    )

def main():
    app = Application.builder().token(TOKEN).build()
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("daily", daily))
    app.add_handler(CommandHandler("answer", answer))
    app.add_handler(CommandHandler("points", points))
    app.add_handler(CommandHandler("premium", premium))
    app.add_handler(MessageHandler(Filters.text & ~Filters.command, handle_message))
    print("Bot iniciado...")
    app.run_polling()

if __name__ == "__main__":
    main()
